# Homemade-Hashing
My novice attempt at learning python by creating a simple hashing program <br>
I started this project as an introduction for myself to learn a bit of python while creating something useful. My goal was to use the standards paper for the SHA-256 hashing algorithm and create a simple tool that could take a string of finite length, and output the SHA-256 hash to the terminal. 
I followed <a href="https://csrc.nist.gov/files/pubs/fips/180-2/final/docs/fips180-2.pdf">this standards document</a> <br><br>
This was my first attempt at learning python, and coding as a whole besides some small attempts as a child. The methods I used here are doubtless not the best implementation, but I digress. <br><br>
What will follow here is a breakdown of my code and an explanation of how I decided upon each method, with pictures attached! <br>
![lines1-10](https://github.com/wtpreston/Homemade-Hashing/assets/168564307/98eafae7-fbfe-4e4b-a9d6-14249d22f7ab) 
The idea for this first section of code was to read a users input, and format it into a concatenated string of binary numbers. This is necessary because the hashing function requires the input to be a very specific length. If the message is *exactly* 512 bits in length, then it can be hashed freely. But this rarely occurs by chance, so some grooming will need to be done to the message so that it can be processed by the hashing function. Essentially I need to measure the length of the string, (Line 3) and find the next multiple of 512 that is *larger* than the message length (Lines 5 through 10). Once the while loop in Line 6 has completed, we're left with two useful pieces of information. the blockCount variable in line 4 will tell us how many 512-bit blocks the message will be divided into. Using this we can determine the 'padCount' which is the number of 0 bits we will append to the message so it fits the exact length required by the algorithm. 
![lines11-20](https://github.com/wtpreston/Homemade-Hashing/assets/168564307/f7b19b02-850a-4d7a-aa02-1f810f2895c5)
<br><br> So we've measured the length of our message and figured out our pad count, how do we proceed from here? First I'll generate a new working string called gMessage, meaning the final groomed message, which will include the padding we determined previously (line 11). Now we need to actually break the groomed message into individual blocks for processing, which I'll store in the messageBlocks array in line 12. Line 13 is a loop that will perform the actual splitting and storing, depending on how many blocks are needed.
<br><br> Line 15 specifically took me a lot of tinkering to figure out, as it was only my second attempt at a bunch of nested methods and functions. I eventually was able to take the messageLength variable, and format it into its 64-bit binary representation. This is then appended to the last item [-1] in the messageBlocks array. This is because the last 64 bits of padding in the message represent the original length.<br><br>

Right at the bottom of that screenshot you can see something sort of unexpected. Lines 17 and 19 are both initializing an array of constants, represented in hexadecimal. Every single hash that is created using SHA-256 originally starts with these constants.![sha-256 constants](https://github.com/wtpreston/Homemade-Hashing/assets/168564307/f2ef6130-122b-438c-b018-8f90db768c85)
 <br>They are derived by performing a lot of destructive math to a series of prime numbers, and are meant to be "randomly" chosen. The values themselves aren't significant in any way, in fact they were derived this way to try and show that they *aren't* significant, and are just there to get everyone on the same page. The reason I find them so interesting is that they are a reminder that hashing functions are meant to be *pseudo-random*. If they were truly random in their output, they would be useless to us for input verification. 

 <br><br> So if every hash starts out with the same constants, how can we process those constants to provide a different output for each input? We utilize something called a compression function. A compression function is basically a list of logical steps and mathematics to apply to the constants while feeding in bits and bits of our messageblocks. No matter how much message we feed into the compression function, the output remains a fixed length - so it's like the information was compressed! In the next few lines I'll use the standards document to define my logic functions in python.<br>
![sha-256 logic functions](https://github.com/wtpreston/Homemade-Hashing/assets/168564307/0c41dc23-8368-4392-bc44-c3b8f36de5ec)
<br>As you can see the SHA-256 function defines 6 logical functions that we'll need to define in our program. These functions are clever combinations of bitwise rotations, inclusive and exclusive ORs, and bitwise shifts to the right. Thankfully all of these bitwise operands are natively supported by python, so defining these functions was actually the easiest part!![lines21-34](https://github.com/wtpreston/Homemade-Hashing/assets/168564307/a89e5c27-b38d-4534-a0d1-84f00ebd5605)
<br><br> Alright so we're almost done! We've chopped up our message into appropriate blocks, initialized our constants and our starting hash values, and now we've defined the logic functions that will make up our compression function. What's next? Essentially it's time to start the actual hashing. <br>![lines35-71](https://github.com/wtpreston/Homemade-Hashing/assets/168564307/b0d731ac-0faf-43e4-bcdb-568ed1762ea3)

<br> These lines were by far the hardest part for me to wrap my head around. Line 35 creates a new array called messageSchedule, which is basically where we'll break up each block and mix in the constants with some logic functions to create a series of 64 32-bit words that we can drop into our compression function. Lines 43 through 69 are simply taking the current hash values, running them through the loop in line 51 64 times, and spittting them back out again. We repeat this process for each messageBlock until the hash values resemble nothing of the original. 
<br> Here's what this looks like in the standards document:![sha-256 working variables](https://github.com/wtpreston/Homemade-Hashing/assets/168564307/8922352b-a407-4676-9d15-8db3d757a526)
<br><br> What we're left with a series of 8 binary number strings that we can concatenate together and convert to hexadecimal in line 70. Printing the string returns the final hash! I'd like to reiterate that this is definitely not the cleanest or most efficient way to implement this hashing function, but this was just a fun way for me to learn python while creating something semi-useful.
